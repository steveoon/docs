---
title: "消息剪裁"
description: "智能管理对话历史，优化 Token 使用"
---

## 什么是消息剪裁？

消息剪裁（Message Pruning）是一种自动管理对话历史长度的机制，在保持对话连贯性的同时，减少不必要的 Token 消耗。

## 为什么需要剪裁？

<CardGroup cols={2}>
  <Card title="降低成本" icon="dollar-sign">
    减少 Token 使用，降低 API 调用成本
  </Card>

{" "}
<Card title="提升性能" icon="bolt">
  减少输入长度，加快模型响应速度
</Card>

{" "}
<Card title="避免超限" icon="triangle-exclamation">
  防止超过模型的上下文长度限制
</Card>

  <Card title="保持质量" icon="star">
    移除冗余信息，保留关键上下文
  </Card>
</CardGroup>

## 启用剪裁

设置 `prune: true` 启用消息剪裁：

```json
{
  "model": "anthropic/claude-3-7-sonnet-20250219",
  "messages": [...],
  "prune": true
}
```

## 剪裁选项

通过 `pruneOptions` 自定义剪裁行为：

```json
{
  "prune": true,
  "pruneOptions": {
    "maxOutputTokens": 15000,
    "targetTokens": 8000,
    "preserveRecentMessages": 2
  }
}
```

### 参数说明

| 参数                     | 默认值 | 说明                          |
| ------------------------ | ------ | ----------------------------- |
| `maxOutputTokens`        | 15000  | 预留给模型输出的最大 Token 数 |
| `targetTokens`           | 8000   | 剪裁后的目标 Token 总数       |
| `preserveRecentMessages` | 2      | 始终保留的最新消息数量        |

## 剪裁策略

系统采用智能剪裁策略：

1. **保留最近消息**：最近的 N 条消息始终保留
2. **移除中间消息**：从较早的消息开始移除
3. **保留系统消息**：系统提示词始终保留
4. **保持完整性**：确保 user/assistant 消息对的完整性

## 检查剪裁结果

响应头 `X-Message-Pruned` 指示是否进行了剪裁：

```http
X-Message-Pruned: true
```

## 完整示例

<CodeGroup>

```javascript JavaScript
const response = await fetch("https://huajune.duliday.com/api/v1/chat", {
  method: "POST",
  headers: {
    Authorization: `Bearer ${apiKey}`,
    "Content-Type": "application/json",
  },
  body: JSON.stringify({
    model: "anthropic/claude-3-7-sonnet-20250219",
    messages: longConversationHistory, // 很长的对话历史
    prune: true,
    pruneOptions: {
      maxOutputTokens: 15000,
      targetTokens: 8000,
      preserveRecentMessages: 3,
    },
    stream: false,
  }),
});

// 检查是否进行了剪裁
const isPruned = response.headers.get("X-Message-Pruned") === "true";
if (isPruned) {
  console.log("消息已剪裁以优化成本");
}
```

```python Python
import requests

url = "https://huajune.duliday.com/api/v1/chat"
headers = {
    "Authorization": f"Bearer {api_key}",
    "Content-Type": "application/json"
}
payload = {
    "model": "anthropic/claude-3-7-sonnet-20250219",
    "messages": long_conversation_history,  # 很长的对话历史
    "prune": True,
    "pruneOptions": {
        "maxOutputTokens": 15000,
        "targetTokens": 8000,
        "preserveRecentMessages": 3
    },
    "stream": False
}

response = requests.post(url, json=payload, headers=headers)

# 检查是否进行了剪裁
is_pruned = response.headers.get('X-Message-Pruned') == 'true'
if is_pruned:
    print('消息已剪裁以优化成本')
```

</CodeGroup>

## 最佳实践

<AccordionGroup>
  <Accordion title="根据场景调整参数">
    不同场景使用不同的剪裁参数：

    - **长对话**：`targetTokens: 6000`, `preserveRecentMessages: 5`
    - **短对话**：禁用剪裁或使用较大的 `targetTokens`
    - **成本敏感**：`targetTokens: 5000`, `preserveRecentMessages: 2`

  </Accordion>

  <Accordion title="监控剪裁效果">
    记录剪裁前后的消息数量：

    ```javascript
    const originalLength = messages.length;

    // 发送请求...

    const isPruned = response.headers.get('X-Message-Pruned');
    if (isPruned) {
      console.log(`消息数从 ${originalLength} 条优化`);
    }
    ```

  </Accordion>

  <Accordion title="结合 Token 统计">
    使用返回的 `usage` 信息监控 Token 消耗：

    ```javascript
    const data = await response.json();
    const { inputTokens, outputTokens, totalTokens } = data.data.usage;

    console.log(`输入: ${inputTokens}, 输出: ${outputTokens}, 总计: ${totalTokens}`);
    ```

  </Accordion>

  <Accordion title="渐进式剪裁">
    对于特别长的对话，可以分阶段剪裁：

    ```javascript
    // 第一阶段：保守剪裁
    let response = await chat(messages, { targetTokens: 10000 });

    // 如果仍然太长，再次剪裁
    if (response.data.usage.inputTokens > 12000) {
      response = await chat(messages, { targetTokens: 7000 });
    }
    ```

  </Accordion>
</AccordionGroup>

## 注意事项

<Warning>
  剪裁会移除部分对话历史，可能影响：
  - 对早期内容的引用
  - 需要完整上下文的任务
  - 多轮复杂推理

建议在关键对话中谨慎使用剪裁功能。

</Warning>

## 性能对比

| 场景           | 不剪裁         | 启用剪裁      | 节省 |
| -------------- | -------------- | ------------- | ---- |
| 100 条消息对话 | ~25,000 tokens | ~8,000 tokens | 68%  |
| 50 条消息对话  | ~12,000 tokens | ~6,000 tokens | 50%  |
| 20 条消息对话  | ~5,000 tokens  | 无需剪裁      | -    |

## 下一步

<CardGroup cols={2}>
  <Card
    title="消息格式"
    icon="message"
    href="/concepts/messages"
  >
    了解消息的结构和格式
  </Card>

  <Card
    title="性能优化"
    icon="gauge-high"
    href="/best-practices/performance"
  >
    学习更多性能优化技巧
  </Card>
</CardGroup>
