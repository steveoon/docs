---
title: "流式输出"
description: "实现打字机效果的实时对话体验"
---

## 什么是流式输出？

流式输出使用 Server-Sent Events (SSE) 协议，实时传输 AI 生成的内容，提供类似 ChatGPT 的打字机效果。

## 启用流式输出

设置 `stream: true`：

```json
{
  "model": "anthropic/claude-3-7-sonnet-20250219",
  "messages": [...],
  "stream": true
}
```

## SSE 事件类型

### text 事件

文本增量更新：

```
event: text
data: {"type":"text.delta","delta":"你"}

event: text
data: {"type":"text.delta","delta":"好"}
```

### tool 事件

工具调用相关事件：

```
event: tool
data: {"type":"tool.start","name":"bash","args":{"command":"ls"}}

event: tool
data: {"type":"tool.output","name":"bash","output":"file1.txt\nfile2.txt"}
```

### usage 事件

Token 使用统计：

```
event: usage
data: {"type":"usage.final","promptTokens":123,"completionTokens":45,"totalTokens":168}
```

### done 事件

流结束标志：

```
event: done
data: {"type":"done"}
```

### error 事件

错误信息：

```
event: error
data: {"type":"error","code":"rate_limit","message":"Rate limit exceeded"}
```

## 客户端实现

<CodeGroup>

```javascript JavaScript
const response = await fetch("https://huajune.duliday.com/api/v1/chat", {
  method: "POST",
  headers: {
    Authorization: `Bearer ${apiKey}`,
    "Content-Type": "application/json",
  },
  body: JSON.stringify({
    model: "anthropic/claude-3-7-sonnet-20250219",
    messages: [{ role: "user", content: "写一首关于春天的诗" }],
    stream: true,
  }),
});

const reader = response.body.getReader();
const decoder = new TextDecoder();

while (true) {
  const { done, value } = await reader.read();
  if (done) break;

  const chunk = decoder.decode(value);
  const lines = chunk.split("\n");

  for (const line of lines) {
    if (line.startsWith("data: ")) {
      const data = JSON.parse(line.slice(6));

      if (data.type === "text.delta") {
        process.stdout.write(data.delta); // 实时输出文本
      }
    }
  }
}
```

```python Python
import requests
import json

url = "https://huajune.duliday.com/api/v1/chat"
headers = {
    "Authorization": f"Bearer {api_key}",
    "Content-Type": "application/json"
}
payload = {
    "model": "anthropic/claude-3-7-sonnet-20250219",
    "messages": [
        {"role": "user", "content": "写一首关于春天的诗"}
    ],
    "stream": True
}

with requests.post(url, json=payload, headers=headers, stream=True) as response:
    for line in response.iter_lines():
        if line:
            decoded = line.decode('utf-8')

            if decoded.startswith('data: '):
                data = json.loads(decoded[6:])

                if data['type'] == 'text.delta':
                    print(data['delta'], end='', flush=True)
```

</CodeGroup>

## React 组件示例

使用 React 实现流式聊天界面：

```jsx
import { useState } from "react";

function ChatBox() {
  const [messages, setMessages] = useState([]);
  const [input, setInput] = useState("");
  const [streaming, setStreaming] = useState(false);

  const sendMessage = async () => {
    if (!input.trim()) return;

    const userMessage = { role: "user", content: input };
    setMessages((prev) => [...prev, userMessage]);
    setInput("");
    setStreaming(true);

    let assistantMessage = { role: "assistant", content: "" };
    setMessages((prev) => [...prev, assistantMessage]);

    const response = await fetch("https://huajune.duliday.com/api/v1/chat", {
      method: "POST",
      headers: {
        Authorization: `Bearer ${apiKey}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        model: "anthropic/claude-3-7-sonnet-20250219",
        messages: messages.concat([userMessage]),
        stream: true,
      }),
    });

    const reader = response.body.getReader();
    const decoder = new TextDecoder();

    while (true) {
      const { done, value } = await reader.read();
      if (done) break;

      const chunk = decoder.decode(value);
      const lines = chunk.split("\n");

      for (const line of lines) {
        if (line.startsWith("data: ")) {
          const data = JSON.parse(line.slice(6));

          if (data.type === "text.delta") {
            setMessages((prev) => {
              const newMessages = [...prev];
              newMessages[newMessages.length - 1].content += data.delta;
              return newMessages;
            });
          }
        }
      }
    }

    setStreaming(false);
  };

  return (
    <div>
      <div className="messages">
        {messages.map((msg, i) => (
          <div key={i} className={msg.role}>
            {msg.content}
          </div>
        ))}
      </div>

      <input
        value={input}
        onChange={(e) => setInput(e.target.value)}
        onKeyPress={(e) => e.key === "Enter" && sendMessage()}
        disabled={streaming}
      />
    </div>
  );
}
```

## 响应头

流式响应包含以下特殊头：

```
Content-Type: text/event-stream; charset=utf-8
Cache-Control: no-cache
X-Accel-Buffering: no
X-Correlation-Id: req_abc123
X-Message-Pruned: true  // 如果启用了消息剪裁
X-Tools-Skipped: tool1,tool2  // 如果有工具被跳过
```

## 最佳实践

<AccordionGroup>
  <Accordion title="错误处理">
    监听 `error` 事件并向用户展示友好的错误信息：

    ```javascript
    if (data.type === 'error') {
      console.error('流式错误:', data.message);
      // 向用户显示错误提示
    }
    ```

  </Accordion>

  <Accordion title="连接超时">
    设置合理的超时时间，处理网络中断：

    ```javascript
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 60000); // 60秒超时

    const response = await fetch(url, {
      signal: controller.signal,
      // ...其他选项
    });

    clearTimeout(timeoutId);
    ```

  </Accordion>

  <Accordion title="性能优化">
    批量更新 UI，避免频繁渲染：

    ```javascript
    let buffer = '';
    let updateTimer = null;

    // 收到数据时
    buffer += data.delta;

    clearTimeout(updateTimer);
    updateTimer = setTimeout(() => {
      // 批量更新 UI
      setContent(prev => prev + buffer);
      buffer = '';
    }, 50); // 每50ms更新一次
    ```

  </Accordion>
</AccordionGroup>

## 下一步

<CardGroup cols={2}>
  <Card
    title="文本对话"
    icon="message"
    href="/features/text-chat"
  >
    了解基础文本对话功能
  </Card>

  <Card
    title="错误处理"
    icon="triangle-exclamation"
    href="/features/error-handling"
  >
    学习如何处理各种错误
  </Card>
</CardGroup>
